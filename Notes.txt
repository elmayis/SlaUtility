
10-3-16
Added read/write threads for COM.
CComThread is no longer a thread. Renamed to CCom.
Updated all classes to compile.

Implementing writing text to the COM...
- Connected CSlaUtilityDlg to CComWriteThread
- Implemented event handler to write to the COM port

10-4-16
Working on read thread...
- Added event handler
- implemented reading from the COM port
- added abitlity to abort the synchronous read operation

10-5-16
After a few bug fixes I was able to connect to the Due successfully.
Attempted to disconnect and was met with an exception.

10-6-16
I found that I was not destroying the read and write thread objects.
Added statement in CCom dtor to destroy the read and write thread objects.
The exception is no longer present BUT CloseHandle does not return. We have a deadlock.
The reason is that ReadFile is waiting on the COM.
- Added CCom::Disconnect
- This method will call Abort on the read and write threads
- It will then post a WM_QUIT message to the thread and wait until it is done
This fixed the disconnect issue. The COM is disconnected successfully.

Need to add logic to enable the appropriate controls after a disconnect event.
Tested OK.

Added a Clear button to clear the contents of the output window.
- The logic did not work
- Found that I needed to remove the ReadOnly flag in the control
Tested OK

Downloaded SerialCallResponse to the Due.
I should get a capital 'A' character when connected.
I am getting garbage.
I discovered that the baud rate is set to 9600. I set the baud rate but am still
getting garbage.

The root cause of the problem is that setting the protocol is incorrect. If I comment out that code and
use the default, then I receive the correct data from the COM port.
I basically set the values that are default and now I can receive data.

10-7-16
Working on writing to the COM port...
- Implemented the Send button in the main dialog
- Added the finished event handler but did not implement the event handler

Testing...
- Deadlock because the read thread is locking the COM port
Will need to revise the read thread so that it will time out and allow another thread to access the port.
May need to refactor and create only 1 thread that will read write.

10-14-16
Accessing the COM must be done synchronously. It seems that you cannot read and write at the same time. Maybe there is a way
but I do not have time to learn that at this point in time. Therefore, I will not be able to have two threads to access the COM.
I will need to revise the code so:
1) one thread accesses the COM
2) the read operation will have a timeout so that it will relinquish access to the COM if no data is ready to be read
3) add a write buffer so that if writing to the COM is delayed all requests to write will be performed

COM thread
* Removing write and read threads and converting CCom as the a CWinThread...
 * Renamed CCom to CComThread
 * Moved implementation from CComReadThread to CComThread
 * Removed CComReadThread
 * Moved implementation from CComWriteThread to CComThread
 * Removed CComWriteThread
Compiles and links but is NOT ready for testing.
Updated the main dialog to create CComThread.
Updated CComThread::Disconnect to stop IO, stop thread, and close COM handle.

Need to redo the protocol

10-17-16
Using Arduino application to set the COM settings. Then I will read the settings to duplicate in the utility.
Below are the settings retrieved after launching and closing the Arduino application.
DWORD DCBlength			= 28
DWORD BaudRate			= 9600
DWORD fBinary			= 1
DWORD fParity			= 0
DWORD fOutxCtsFlow		= 0
DWORD fOutxDsrFlow		= 0
DWORD fDtrControl		= 1
DWORD fDsrSensitivity	= 0
DWORD fTXContinueOnXoff	= 1
DWORD fOutX				= 0
DWORD fInX				= 0
DWORD fErrorChar		= 0
DWORD fNull				= 0
DWORD fRtsControl		= 1
DWORD fAbortOnError		= 0
DWORD fDummy2			= 0
WORD wReserved			= 0
WORD XonLim				= 2048
WORD XoffLim			= 512
BYTE ByteSize			= 8		'\xb'
BYTE Parity				= 0		'\x0'
BYTE StopBits			= 0		'\x0'
char XonChar			= 17	'\x11'
char XoffChar			= 19	'\x13'
char ErrorChar			= 0		'\x0'
char EofChar			= 0		'\x0'
char EvtChar			= 0		'\x0'
WORD wReserved1			= 0

I updated the code to set the above settings.
Since the IO operations are synchronous to minimize complexity, I need ReadFile to timeout if no data is available.
The structure COMMTIMEOUTS is used for this.

Need to read the current timeout settings then update OnReadCom.